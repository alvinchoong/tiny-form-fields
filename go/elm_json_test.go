package tinyformfields

import (
	"encoding/json"
	"io/ioutil"
	"net/url"
	"testing"
)

// TestElmGeneratedJSON tests that Go can validate JSON structures generated by Elm
// This ensures that Elm and Go stay in sync on JSON schema
func TestElmGeneratedJSON(t *testing.T) {
	// Read the JSON fixtures generated by Elm
	fixturesData, err := ioutil.ReadFile("testdata/elm_json_fixtures.json")
	if err != nil {
		t.Fatalf("Failed to read testdata/elm_json_fixtures.json - run 'make generate-go-test-json' first: %v", err)
	}

	// Parse the fixtures
	var fixtures map[string]json.RawMessage
	if err := json.Unmarshal(fixturesData, &fixtures); err != nil {
		t.Fatalf("Failed to parse testdata/elm_json_fixtures.json: %v", err)
	}

	testCases := []struct {
		name      string
		values    url.Values
		shouldErr bool
		errMsg    string
	}{
		{
			name: "showWhenVisibilityRule",
			values: url.Values{
				"color":   []string{"Red"},
				"why_red": []string{"Because I like it"},
			},
			shouldErr: false,
		},
		{
			name: "showWhenVisibilityRule - visible but empty",
			values: url.Values{
				"color": []string{"Red"},
				// why_red is missing - should fail validation
			},
			shouldErr: true,
			errMsg:    "required field missing: why_red",
		},
		{
			name: "showWhenVisibilityRule - hidden and empty",
			values: url.Values{
				"color": []string{"Blue"},
				// why_red is hidden - should pass validation even though it's missing
			},
			shouldErr: false,
		},
		{
			name: "hideWhenVisibilityRule",
			values: url.Values{
				"has_comments": []string{"Yes"},
				"comments":     []string{"These are my comments"},
			},
			shouldErr: false,
		},
		{
			name: "hideWhenVisibilityRule - visible but empty",
			values: url.Values{
				"has_comments": []string{"Yes"},
				// comments field is missing - should fail
			},
			shouldErr: true,
			errMsg:    "required field missing: comments",
		},
		{
			name: "hideWhenVisibilityRule - hidden and empty",
			values: url.Values{
				"has_comments": []string{"No"},
				// comments field is hidden - should pass even though missing
			},
			shouldErr: false,
		},
		{
			name: "stringContainsRule - visible",
			values: url.Values{
				"description": []string{"This is an urgent matter"},
				"urgent_note": []string{"Handle ASAP"},
			},
			shouldErr: false,
		},
		{
			name: "stringContainsRule - hidden",
			values: url.Values{
				"description": []string{"This is a normal matter"},
				// urgent_note is hidden - should pass even though missing
			},
			shouldErr: false,
		},
		{
			name: "greaterThanNumericRule - visible",
			values: url.Values{
				"score":          []string{"150"},
				"high_score_msg": []string{"Great job!"},
			},
			shouldErr: false,
		},
		{
			name: "greaterThanNumericRule - hidden",
			values: url.Values{
				"score": []string{"50"},
				// high_score_msg is hidden - should pass even though missing
			},
			shouldErr: false,
		},
		{
			name: "requiredHiddenField - visible",
			values: url.Values{
				"show_details": []string{"Yes"},
				"details":      []string{"Here are the details"},
			},
			shouldErr: false,
		},
		{
			name: "requiredHiddenField - hidden",
			values: url.Values{
				"show_details": []string{"No"},
				// details is hidden - should pass even though missing
			},
			shouldErr: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			fixtureKey := tc.name
			// Extract the base fixture name (everything before the first " - ")
			if idx := findFirstIndex(tc.name, " - "); idx != -1 {
				fixtureKey = tc.name[:idx]
			}

			formFieldsJSON, exists := fixtures[fixtureKey]
			if !exists {
				t.Fatalf("Test fixture '%s' not found in testdata/elm_json_fixtures.json", fixtureKey)
			}

			// Validate the form
			err := ValidFormValues([]byte(formFieldsJSON), tc.values)

			if tc.shouldErr {
				if err == nil {
					t.Errorf("Expected validation to fail but it passed")
				} else if tc.errMsg != "" && err.Error() != tc.errMsg {
					t.Errorf("Expected error message %q but got %q", tc.errMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Expected validation to pass but got error: %v", err)
				}
			}
		})
	}
}

// Helper function to find first occurrence of substring
func findFirstIndex(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}